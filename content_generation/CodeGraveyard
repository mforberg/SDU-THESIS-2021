MAIN:
    # def smart_row_read(self, min_x, max_x, min_z, max_z):
    #     surface_dict = {}
    #     first_read = True
    #     row_y = 100
    #     last_y = 100
    #     for x in range(min_x, max_x+1):
    #         new_row = True
    #         for z in range(min_z, max_z+1):
    #             if first_read:
    #                 block = self.find_surface(x, z)
    #                 surface_dict[x, z] = {"y": block.position.y, "type": block.type, "block": block}
    #                 last_y = block.position.y
    #                 first_read = False
    #             else:
    #                 if new_row:
    #                     last_y = row_y
    #                     block = self.find_surface(x, z, last_y)
    #                     surface_dict[x, z] = {"y": block.position.y, "type": block.type, "block": block}
    #                     last_y = block.position.y
    #                     row_y = block.position.y
    #                     new_row = False
    #                 else:
    #                     block = self.find_surface(x, z, last_y)
    #                     surface_dict[x, z] = {"y": block.position.y, "type": block.type, "block": block}
    #                     last_y = block.position.y
    #     return surface_dict
    #
    # def find_surface(self, x, z, y=160):
    #     counter = 0
    #     surface_found = False
    #     last_was_in_skip_list = False
    #     read_more_than_once = False
    #     old_block = None
    #     while not surface_found:
    #         counter += 1
    #         block = self.read_block(x, z, y)[0]
    #         if counter > 300:
    #             return -1
    #         elif block.type in skip_list:
    #             if not last_was_in_skip_list and read_more_than_once:
    #                 return old_block
    #             old_block = block
    #             y -= 1
    #             last_was_in_skip_list = True
    #             read_more_than_once = True
    #             continue
    #         else:
    #             if last_was_in_skip_list and read_more_than_once:
    #                 return block
    #             old_block = block
    #             y += 1
    #             last_was_in_skip_list = False
    #             read_more_than_once = True
    #             continue
    #
    # def read_block(self, x, z, y):
    #     result = client.readCube(Cube(
    #         min=Point(x=x, y=y, z=z),
    #         max=Point(x=x, y=y, z=z)
    #     ))
    #
    #     return result.blocks

map_analysis
    # def find_areas_for_districts(self, surface_dict):
    #     areas = []
    #     checked_nodes = []
    #     nodes_to_be_checked = []
    #     current_area = []
    #     for block in surface_dict:
    #         nodes_to_be_checked.append(block)
    #         current_area.append(block)
    #         break
    #     while nodes_to_be_checked:
    #         current_node = nodes_to_be_checked.pop()
    #         checked_nodes.append(current_node)
    #         neighbors = self.get_neighbors(surface_dict, current_node[0], current_node[1])
    #         for neighbor in neighbors:
    #             nodes_to_be_checked.append(neighbor)
    #             if surface_dict[current_node]['y'] == surface_dict[neighbor]['y']:
    #                 current_area.append(neighbor)
    #     return areas

MAP_GA FITNESS
    # def duplicates_fitness(self, duplicate_areas: dict) -> float:
    #     # Duplicates? (good or bad depending on size)
    #     fitness = FITNESS_DUPLICATE_DEFAULT_SCORE
    #     duplicate_combined_fitness = 0
    #     duplicates_amount = 0
    #     for value in duplicate_areas.values():
    #         if value['repetitions'] > 1:
    #             duplicates_amount += 1
    #             value_should_be_close_to_repetitions = value['length'] / FITNESS_AREA_PER_DISTRICT_FOR_SHARED_SPACE
    #             diff = abs(value_should_be_close_to_repetitions - value['repetitions'])
    #             # 0 is perfect score, anything higher than that should decrease the score
    #             # y = a*x + b
    #             # a = y2 - y1 / x2 - x1 (y1 is max score, x1 is 0, x2 is 0.5, and y2 is 0)
    #             # b = (max score)
    #             # x = difference
    #             a = -FITNESS_DUPLICATE_PERFECT_AMOUNT_SCORE / 0.5
    #             duplicate_combined_fitness += a * diff + FITNESS_DUPLICATE_PERFECT_AMOUNT_SCORE
    #     if duplicates_amount != 0:
    #         fitness += duplicate_combined_fitness / duplicates_amount
    #     return fitness
    #
    #
    # def pillar_fitness(self, area_set: set, min_max_values: dict) -> float:
    #     min_x = min_max_values['min_x']
    #     max_x = min_max_values['max_x']
    #     min_z = min_max_values['min_z']
    #     max_z = min_max_values['max_z']
    #     step_size_x = int(round((max_x-min_x)/2))
    #     step_size_z = int(round((max_z-min_z)/2))
    #     total_possible_pillars = 0
    #     amount_of_pillars_found = 0
    #     for x in range(min_x, max_x, step_size_x):
    #         for z in range(min_z, max_z, step_size_z):
    #             if (x, z) in area_set:
    #                 amount_of_pillars_found += 1
    #             total_possible_pillars += 1
    #     fitness = (FITNESS_PILLAR_MAX_SCORE / total_possible_pillars) * amount_of_pillars_found
    #     return fitness

    # def distance_from_min_to_max_corners(self, min_max_values: dict) -> float:
    #     min_x = min_max_values['min_x']
    #     max_x = min_max_values['max_x']
    #     min_z = min_max_values['min_z']
    #     max_z = min_max_values['max_z']
    #     # a^2 + b^2 = c^2
    #     x_distance = max_x - min_x
    #     z_distance = max_z - min_z
    #     distance = math.sqrt(math.pow(x_distance, 2) + math.pow(z_distance, 2)) - FITNESS_CORNERS_DISTANCE_FOR_MAX_SCORE
    #     if distance <= 0:
    #         return FITNESS_CORNERS_MAX_SCORE
    #     # y = a*x + b
    #     # a = y2 - y1 / x2 - x1 (y1 is max score, x1 is 0, y2 is 0, x2 is the max cut for 0 points)
    #     # b = max score
    #     # x = distance
    #     a = (-FITNESS_CORNERS_MAX_SCORE / FITNESS_ALTITUDE_MAX_ALLOWED_DIFFERENCE_BEFORE_MINUS)
    #     return a * distance + FITNESS_CORNERS_MAX_SCORE